<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Statistics for Social Scientists</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="5_files/libs/clipboard/clipboard.min.js"></script>
<script src="5_files/libs/quarto-html/quarto.js"></script>
<script src="5_files/libs/quarto-html/popper.min.js"></script>
<script src="5_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="5_files/libs/quarto-html/anchor.min.js"></script>
<link href="5_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="5_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="5_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="5_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="5_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Statistics for Social Scientists</h1>
            <p class="subtitle lead">Lesson 2.5: Method of Moments and Instrumental Variables</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Lesson 2.5: Method of Moments and Instrumental Variables</h2>
   
  <ul class="collapse">
  <li><a href="#ols-as-a-method-of-moments-estimator" id="toc-ols-as-a-method-of-moments-estimator" class="nav-link active" data-scroll-target="#ols-as-a-method-of-moments-estimator">2.5.1: OLS as a Method of Moments Estimator</a></li>
  <li><a href="#ols-as-a-method-of-moments-estimator-1" id="toc-ols-as-a-method-of-moments-estimator-1" class="nav-link" data-scroll-target="#ols-as-a-method-of-moments-estimator-1">2.5.2: OLS as a Method of Moments Estimator</a></li>
  <li><a href="#endogeneity-and-instrumental-variables." id="toc-endogeneity-and-instrumental-variables." class="nav-link" data-scroll-target="#endogeneity-and-instrumental-variables.">2.5.3: Endogeneity and Instrumental Variables.</a></li>
  <li><a href="#instrumental-variables-estimator" id="toc-instrumental-variables-estimator" class="nav-link" data-scroll-target="#instrumental-variables-estimator">2.5.4: Instrumental Variables Estimator</a></li>
  <li><a href="#asymptotic-consistency-of-the-instrumental-variables-estimator" id="toc-asymptotic-consistency-of-the-instrumental-variables-estimator" class="nav-link" data-scroll-target="#asymptotic-consistency-of-the-instrumental-variables-estimator">2.5.5: Asymptotic Consistency of the Instrumental Variables Estimator</a></li>
  <li><a href="#variance-of-the-estimator-and-weak-instruments" id="toc-variance-of-the-estimator-and-weak-instruments" class="nav-link" data-scroll-target="#variance-of-the-estimator-and-weak-instruments">2.5.6: Variance of the Estimator and Weak Instruments</a></li>
  <li><a href="#two-stage-least-squares-estimator" id="toc-two-stage-least-squares-estimator" class="nav-link" data-scroll-target="#two-stage-least-squares-estimator">2.5.7: Two-Stage Least Squares Estimator</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Lesson Overview
</div>
</div>
<div class="callout-body-container callout-body">
<p>This lesson introduces a new estimator: the method of moments estimator. Then, we discuss how OLS can be considered a special case of the method of moments estimator. Finally, we discuss how endogeneity leads to an invalid moment condition, biasing OLS estimates, and how we can resolve this with an instrumental variable.</p>
<p>This lesson covers the following topics:</p>
<ul>
<li>An introduction to the method of moments estimator.</li>
<li>A discussion on how OLS is a method of moments estimator.</li>
<li>Introducing instrumental variables as a solution to endogeneity in the framework of method of moments.</li>
<li>Discussing the instrumental variables estimator, its properties, and its variance.</li>
</ul>
</div>
</div>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
<section id="ols-as-a-method-of-moments-estimator" class="level1">
<h1>2.5.1: OLS as a Method of Moments Estimator</h1>
<p>We have mostly focused on one specific estimator: the Ordinary Least Squares estimator. However, in this section, we will focus on another estimator, the method of moments estimator.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Method of Moments Estimator
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Method of Moments Estimator is another estimator of the true value of populations in the parameter. The estimator defines key population <strong>moments</strong> of interest - which are the population parameters written in terms of expected value functions set equal to 0.</p>
<p>Then, the Method of Moments uses the sample equivalents of the population moments to estimate the population parameter.</p>
<ul>
<li>For example, to estimate the population mean, the Method of Moments uses the sample mean.</li>
</ul>
</div>
</div>
<p><br></p>
<p>In general, in order to define a method of moments for a set of parameters <span class="math inline">\theta_1, \dots, \theta_k</span>, we need to specify at least one population moment per parameter. Or in other words, we must have more than <span class="math inline">k</span> population moments.</p>
<p>Our population moments can be defined as the expected value of some function <span class="math inline">m(\theta; y)</span> that consists of both the variable <span class="math inline">y</span> and our unknown parameter <span class="math inline">\theta</span>. The expectation of the function <span class="math inline">m(\theta; y)</span> should equal 0.</p>
<p><span class="math display">
E(m(\theta; y)) = 0
</span></p>
<p>Our sample moments will be the sample analogues of <span class="math inline">\theta</span> and <span class="math inline">y</span>, which are <span class="math inline">\hat\theta</span> and <span class="math inline">y_i</span>:</p>
<p><span class="math display">
\frac{1}{n}\sum\limits_{i=1}^n m(\hat\theta; y_i) = 0
</span></p>
<ul>
<li>The <span class="math inline">\frac{1}{n} \sum</span> is there because the definition of expectation/mean is that.</li>
</ul>
<p>This is a little hard to understand, so let us go into a example.</p>
<p><br></p>
<section id="estimating-mean-with-method-of-moments" class="level3">
<h3 class="anchored" data-anchor-id="estimating-mean-with-method-of-moments">Estimating Mean with Method of Moments</h3>
<p>Let us say that we have some random variable <span class="math inline">y</span>, with a true population mean <span class="math inline">\mu</span>. We want to estimate <span class="math inline">\mu</span>, but we only have a sample of the population.</p>
<p>How can we define our true population parameter <span class="math inline">\mu</span> in an expectation equation of the form: <span class="math inline">E(m(\mu, y)) = 0</span>?</p>
<ul>
<li>Well, what is <span class="math inline">\mu</span>, the mean, intuitively speaking? It is the expectation of <span class="math inline">y</span>, so <span class="math inline">\mu = E(y)</span>.</li>
</ul>
<p>Now that we know that <span class="math inline">\mu = E(y)</span>, since they are equal, <span class="math inline">\mu - E(y) = 0</span>. Thus, we can define the mean as a moment of the following condition:</p>
<p><span class="math display">
E(y - \mu) = 0
</span></p>
<p>The method of moments says we should use the sample equivalent of the population parameter. The sample equivalent of <span class="math inline">\mu</span> (the true mean of the population), is of course, the sample mean <span class="math inline">\bar y</span>.</p>
<p>Thus, our sample estimate of the moment would be:</p>
<p><span class="math display">
E(y_i - \hat\mu) = \frac{1}{n}\sum\limits_{i=1}^n (y_i - \hat\mu) = 0
</span></p>
<p>With this equation, we can then solve for <span class="math inline">\hat\mu</span>:</p>
<p><span class="math display">
\begin{split}
0 &amp; = \frac{1}{n}\sum\limits_{i=1}^n (y_i - \hat\mu) \\
0 &amp; = \frac{1}{n}\sum\limits_{i=1}^ny_i - \frac{1}{n}\sum\limits_{i=1}^n \hat\mu \\
0 &amp; = \frac{1}{n}\sum\limits_{i=1}^ny_i - \frac{1}{n} n \hat\mu\\
0 &amp; = \bar y - \hat \mu \\
\hat\mu &amp; = \bar y
\end{split}
</span></p>
<p>So, we see the method of moments estimates our true population mean <span class="math inline">\mu</span>, with the sample mean <span class="math inline">\bar y</span>.</p>
<p>Method of moments estimators are generally asymptotically consistent. This is because of the law of large numbers introduced in <a href="https://statsnotes.github.io/metrics/1.html#asymptotic-consistency-of-estimators">2.1.5</a>. However, method of moments estimators can be biased in small sample sizes.</p>
<p>But why do we care about the method of moments estimator? In the next section, we will discuss how OLS is also thought of as a method of moments estimator.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
</section>
<section id="ols-as-a-method-of-moments-estimator-1" class="level1">
<h1>2.5.2: OLS as a Method of Moments Estimator</h1>
<p>OLS can also be considered a Method of Moments estimator. For simplicity, let us use simple linear regression. We will have moments for each parameter <span class="math inline">\beta_0</span> and <span class="math inline">\beta_1</span> we are trying to estimate.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Bivariate Regression as a Method of Moments Estimator
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the bivariate regression model:</p>
<p><span class="math display">
y = \beta_0 + \beta_1x + u
</span></p>
<p>The OLS estimator can be derived as a method of moments estimator, with 2 moments (expectation functions set equal to 0), one for each parameter (<span class="math inline">\beta_0, \beta_1</span>):</p>
<p><span class="math display">
\begin{split}
&amp; E(y-\beta_0 -\beta_1x) = 0 \\
&amp; E(x(y - \beta_0 - \beta_1 x)) = 0
\end{split}
</span></p>
<p>Since we know <span class="math inline">u = y - \beta_0 - \beta_1 x</span>, we can rewrite the two moments as:</p>
<p><span class="math display">
\begin{split}
&amp; E(u) = 0 \\
&amp; E(xu) = 0
\end{split}
</span></p>
<p>The estimates of these moments would use the sample equivalents: <span class="math inline">\hat\beta_0</span> and <span class="math inline">\hat\beta_1</span>.</p>
<p><span class="math display">
\begin{split}
&amp; E(y-\hat\beta_0 -\hat\beta_1x) = 0 \\
&amp; E(x(y - \hat\beta_0 - \hat\beta_1 x)) = 0
\end{split}
</span></p>
</div>
</div>
<p><br></p>
<p>Let us prove that OLS is a special case of the method of moments estimator. Remember our OLS minimisation conditions from <a href="https://statsnotes.github.io/metrics/2.html#estimation-for-simple-linear-regression">2.2.2</a>:</p>
<p><span class="math display">
\begin{split}
&amp; \sum\limits_{i=1}^n (y_i - \hat{\beta}_0 - \hat{\beta}_1 x_i) = 0 \\
&amp; \sum\limits_{i=1}^n x_i (y_i - \hat{\beta}_0 - \hat{\beta}_1 x_i) = 0
\end{split}
</span></p>
<p>Since by definition, average/expectation is <span class="math inline">E(x) = \frac{1}{n} \sum x_i</span>, we can rewrite the OLS minimisation conditions as:</p>
<p><span class="math display">
\begin{split}
&amp; n \times E(y_i - \hat\beta_0 - \hat\beta_1x_i) = 0 \\
&amp; n \times E(x_i(y_i - \hat\beta_0 - \hat\beta_1x_i)) = 0
\end{split}
</span></p>
<p>And since anything multiplied to a zero turns into zero, we can ignore the <span class="math inline">n</span> in the first order condition, and only focus on the expected value part. Thus, our conditions are:</p>
<p><span class="math display">
\begin{split}
&amp; E(y_i - \hat\beta_0 - \hat\beta_1x_i) = 0 \\
&amp; E(x_i(y_i - \hat\beta_0 - \hat\beta_1x_i)) = 0
\end{split}
</span></p>
<p>Which as we can see, are the exact same minimisation conditions as the method of moments estimator. Thus, the OLS estimator is a special case of the Method of Moments estimator, and they produce the same coefficients.</p>
<p><br></p>
<p>Note how the two moment conditions of the Method of Moments estimator can be written as:</p>
<p><span class="math display">
\begin{split}
&amp; E(u) = 0 \\
&amp; E(xu) = 0
\end{split}
</span></p>
<p>These moments also imply that <span class="math inline">Cov(x,u) = 0</span>, as we discussed in <a href="https://statsnotes.github.io/metrics/3.html#exogeneity-and-endogeneity">2.3.6</a>. This is the assumption of exogeneity.</p>
<p>Thus, if <span class="math inline">Cov(x,u)≠0</span>, we do not meet exogeneity, and have endogeneity present. Under endogeneity, if we use the OLS estimator, we will be estimating our parameters with an invalid moment condition - since the moments are not true if endogeneity is present.</p>
<ul>
<li>This is another reason why violating endogeneity produces biased (and asymptotically inconsistent) estimates - since endogeneity means the moment conditions are invalid.</li>
</ul>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
<section id="endogeneity-and-instrumental-variables." class="level1">
<h1>2.5.3: Endogeneity and Instrumental Variables.</h1>
<p>In the presence of endogeneity, it is inappropriate to use the OLS estimator. This is because OLS, when <span class="math inline">Cov(x,u)≠0</span> is both a biased and asymptotically inconsistent estimator.</p>
<ul>
<li>When <span class="math inline">Cov(x,u) ≠ 0</span>, <span class="math inline">x</span> is called an <strong>endogenous regressor</strong>.</li>
</ul>
<p>Our current set up (if we have endogeneity) is:</p>
<p><span class="math display">
y_i = \beta_0 + \beta_1 x + u_i, \quad E(u) = 0, \ E(xu)≠0
</span></p>
<p>Our second moment condition <span class="math inline">E(xu) = 0</span> is being violated.</p>
<p><br></p>
<p>To ensure that this condition is not violated, we can find some new variable <span class="math inline">z</span> that can provide a valid moment condition:</p>
<p><span class="math display">
Cov(z,u) = E(zu) = 0
</span></p>
<p>This new variable <span class="math inline">z</span> that provides a valid moment condition is called an <strong>instrumental variable</strong>. The idea of this variable <span class="math inline">z</span> is that we can first use <span class="math inline">z</span> to explain <span class="math inline">x</span>, then use the part of <span class="math inline">x</span> explained by <span class="math inline">z</span> to explain <span class="math inline">y</span>.</p>
<ul>
<li>So first, we find the part of <span class="math inline">x</span> explained by <span class="math inline">z</span>, which we will label as <span class="math inline">\hat x</span>.</li>
<li>Then, we find the relationship between <span class="math inline">\hat x</span> and <span class="math inline">y</span>.</li>
</ul>
<p>Thus, in our second step, we are only using <span class="math inline">\hat x</span> in our relationship, instead of <span class="math inline">x</span>.</p>
<ul>
<li>Since <span class="math inline">\hat x</span> is explained by <span class="math inline">z</span>, and <span class="math inline">z</span> is uncorrelated to the error term <span class="math inline">u</span>, then <span class="math inline">\hat x</span> should also be uncorrelated with the error term <span class="math inline">u</span>.</li>
<li>This, if <span class="math inline">Cov(\hat x, u) = 0</span>, then our moment condition is valid again.</li>
</ul>
<p><br></p>
<p>Of course, for this procedure to work, the instrumental variable <span class="math inline">z</span> must meet a few conditions:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Instrumental Variable
</div>
</div>
<div class="callout-body-container callout-body">
<p>New variable <span class="math inline">z</span> is called an instrumental variable, or instrument, for the endogeneous regressor <span class="math inline">x</span>, if it satisfies three conditions:</p>
<ol type="1">
<li><span class="math inline">z</span> is <strong>exogenous</strong> to our original model, i.e.&nbsp;<span class="math inline">Cov(z,u) = 0</span>. This is because if this was not true, variable <span class="math inline">z</span> would introduce more endogeneity, which would not fix our biased and inconsistent OLS estimates.</li>
<li><span class="math inline">z</span> is <strong>relevant</strong> for explaining <span class="math inline">x</span>, i.e., <span class="math inline">Cov(z,x)≠0</span>. Essentially, <span class="math inline">z</span> must have some correlation with <span class="math inline">x</span>.</li>
<li>The <strong>exclusions restriction</strong>. This restriction essentially says that <span class="math inline">z</span> should have no independent effect on outcome <span class="math inline">y</span>. The only effect <span class="math inline">z</span> has on <span class="math inline">y</span> should be through <span class="math inline">x</span>.</li>
</ol>
</div>
</div>
<p>If we have found a valid instrument <span class="math inline">z</span>, we can then apply this back into our method of moments estimator to find the relationship between <span class="math inline">x</span> and <span class="math inline">y</span>. We will show this in the next section.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
<section id="instrumental-variables-estimator" class="level1">
<h1>2.5.4: Instrumental Variables Estimator</h1>
<p>We start with the linear model:</p>
<p><span class="math display">
y_i = \beta_0 + \beta_1 x_i + u_i
</span></p>
<p>Now, let us try to estimate <span class="math inline">\beta_1</span> using an instrumental variable <span class="math inline">z</span>. The instrument <span class="math inline">z</span> should satisfy:</p>
<p><span class="math display">
Cov(z,u) = 0, \quad Cov(z,x)≠0
</span></p>
<p>We now re-do our linear model, but only with the parts explained by instrument <span class="math inline">z</span>.</p>
<ul>
<li>The part of <span class="math inline">y</span> explained by <span class="math inline">z</span> is <span class="math inline">Cov(z,y)</span>.</li>
<li>The part of <span class="math inline">x</span> explained by <span class="math inline">z</span> is <span class="math inline">Cov(z,x)</span>.</li>
<li>The part of <span class="math inline">u</span> explained by <span class="math inline">z</span> is <span class="math inline">Cov(z,u)</span>.</li>
</ul>
<p>Thus, we can transform our linear model to the following:</p>
<p><span class="math display">
Cov(z,y) = \beta_1 \ Cov(z,x) + Cov(z,u)
</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exogeneity of the Instrument
</div>
</div>
<div class="callout-body-container callout-body">
<p>One of the assumptions of the instrument <span class="math inline">z</span> is that it is exogenous: <span class="math inline">Cov(z,u) = 0</span>.</p>
</div>
</div>
<p>Knowing this assumption, we can plug this back into our model:</p>
<p><span class="math display">
\begin{split}
Cov(z,y) &amp; = \beta_1 \ Cov(z,x) + Cov(z,u) \\
Cov(z,y) &amp; = \beta_1 \ Cov(z,x) + 0 \\
Cov(z,y) &amp; = \beta_1 \ Cov(z,x)
\end{split}
</span></p>
<p>Now, we can solve for <span class="math inline">\beta_1</span>:</p>
<p><span class="math display">
\begin{split}
Cov(z,y) &amp; = \beta_1 \ Cov(z,x) \\
\beta_1 &amp; = \frac{Cov(z,y)}{Cov(z,x)}
\end{split}
</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Relevance of the Instrument
</div>
</div>
<div class="callout-body-container callout-body">
<p>One of the assumptions of the instrument <span class="math inline">z</span> is that it is relevant: <span class="math inline">Cov(z, x) ≠ 0</span>.</p>
</div>
</div>
<p>Knowing that the condition of relevance is met, we know that our denominator will not be 0, and our <span class="math inline">\beta_1</span> will exist.</p>
<p>This is the true population value of <span class="math inline">\beta_1</span>. We can estimate this by using the sample analogues.</p>
<ul>
<li>The sample analogue of <span class="math inline">Cov(z,y)</span> is the sample covariance <span class="math inline">S.Cov(z,y)</span>.</li>
<li>The sample analogue of <span class="math inline">Cov(z,x)</span> is the sample covariance <span class="math inline">S.Cov(z,y)</span>.</li>
</ul>
<p>We can plug them into our <span class="math inline">\beta_1</span> value to get our estimate <span class="math inline">\hat\beta_1</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Instrumental Variables Estimator
</div>
</div>
<div class="callout-body-container callout-body">
<p>The instrumental variables estimate <span class="math inline">\hat\beta_1</span> is the following:</p>
<p><span class="math display">
\hat\beta_1^{IV} = \frac{S.Cov(z,y)}{S.Cov(z,x)} = \frac{\sum_{i=1}^n (z_i - \bar z)(y_i - \bar y)}{\sum_{i=1}^n (z_i - \bar z)(x_i - \bar x)}
</span></p>
</div>
</div>
<p><br></p>
<p>Of course, so far, we have only estimated <span class="math inline">\beta_1</span>, not <span class="math inline">\beta_0</span>. Let us estimate <span class="math inline">\beta_0</span>. We have the following linear model:</p>
<p><span class="math display">
y = \beta_0 + \beta_1 x + u
</span></p>
<p>Let us find <span class="math inline">E(y)</span>. We know that one of the population moments is <span class="math inline">E(u) = 0</span>. Thus:</p>
<p><span class="math display">
\begin{split}
E(y) &amp; = E(\beta_0) + E(\beta_1x) + E(u)\\
E(y) &amp; = \beta_0 + \beta_1 E(x) + 0 \\
E(y) &amp; = \beta_0 + \beta_1 E(x)
\end{split}
</span></p>
<p>Now, solve for <span class="math inline">\beta_0</span> as follows:</p>
<p><span class="math display">
\begin{split}
E(y) &amp; = \beta_0 + \beta_1 E(x) \\
\beta_0 &amp; = E(y) - \beta_1E(x)
\end{split}
</span></p>
<p>Of course, we do not know the population expected value <span class="math inline">E(y)</span> and <span class="math inline">E(x)</span>. Thus, we use their sample analogues - the sample mean. We also do not know <span class="math inline">\beta_1</span>, so we can use our earlier sample estimate <span class="math inline">\hat\beta_1^{IV}</span>.</p>
<p>Thus, we can get our instrumental variables estimate <span class="math inline">\hat\beta_0^{IV}</span>.</p>
<p><span class="math display">
\hat\beta_0^{IV} = \bar y - \hat\beta_1^{IV}\bar x
</span></p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
<section id="asymptotic-consistency-of-the-instrumental-variables-estimator" class="level1">
<h1>2.5.5: Asymptotic Consistency of the Instrumental Variables Estimator</h1>
<p>The instrumental variables estimator <span class="math inline">\hat\beta_1^{IV}</span> is asymptotically consistent - as we increase sample size towards infinity, the estimate will become more and more concentrated around the true population value <span class="math inline">\beta_1</span>. More mathematically:</p>
<p><span class="math display">
\text{plim}(\hat\beta_1^{IV}) = \beta_1
</span></p>
<p>To prove this, we will need to know some properties of probability limits.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Properties of Probability Limits
</div>
</div>
<div class="callout-body-container callout-body">
<p>We know these general rules about probability limits (see <a href="https://statsnotes.github.io/metrics/1.html#asymptotic-consistency-of-estimators">2.1.5</a>)</p>
<p><span class="math display">
\begin{split}
&amp; \text{plim}(\bar x_n) = \mu _x \\
&amp; \text{plim}(S.Var(x_i)) = Var(x_i) \\
&amp; \text{plim}(S.Cov(x_i, y_i)) = Cov (x_i, y_i)
\end{split}
</span></p>
<p>The other properties are about algebra with probability limits. Assume <span class="math inline">\text{plim} (u_n) = a</span>, and <span class="math inline">\text{plim}(v_n) = b</span>. Then, the following are true:</p>
<p><span class="math display">
\begin{split}
&amp; \text{plim} (u_n + v_n) = a + b \\
&amp; \text{plim} (u_n v_n) = ab \\
&amp; \text{plim} (u_n v_n) = a/b
\end{split}
</span></p>
</div>
</div>
<p>Knowing this, we can prove the asymptotic consistency of the instrumental variables estimator.</p>
<p>Let us remind ourselves of the instrumental variables estimator:</p>
<p><span class="math display">
\hat\beta_1^{IV} = \frac{S.Cov(z,y)}{S.Cov(z,x)}
</span></p>
<p>Now, let us find <span class="math inline">\text{plim}(\hat\beta_1^{IV})</span> using the properties introduced above:</p>
<p><span class="math display">
\begin{split}
\text{plim}(\hat\beta_1^{IV}) &amp; = \text{plim} \left( \frac{S.Cov(z,y)}{S.Cov(z,x)} \right) \\
\text{plim}(\hat\beta_1^{IV}) &amp; = \frac{\text{plim}(S.Cov(z,y))}{\text{plim}(S.Cov(z,x))} \\
\text{plim}(\hat\beta_1^{IV}) &amp; = \frac{Cov(z,y)}{Cov(z,x)} \\
\text{plim}(\hat\beta_1^{IV}) &amp; = \beta_1
\end{split}
</span></p>
<ul>
<li>The last simplification was derived earlier during our derivation of the instrumental variables estimator.</li>
</ul>
<p><br></p>
<p>Note that this shows that under the assumptions of an instrument <span class="math inline">z</span> (exogeneity, relevance, exclusion), the instrumental variables estimate <span class="math inline">\hat\beta_1^{IV}</span> is asymptotically consistent.</p>
<p>This does not mean that instrumental variables estimates are unbiased in smaller sample sizes. We will discuss this much more in Part III of the course, where we discuss the experimental designs with instrumental variables.</p>
<p><br></p>
<p>We can also prove that the instrumental variables estimator <span class="math inline">\hat\beta_0^{IV}</span> is asymptotically consistent, using the properties of probability limits:</p>
<p><span class="math display">
\begin{split}
\text{plim}(\hat\beta_0^{IV}) &amp; = \text{plim}( \bar y - \hat\beta_1^{IV} \bar x) \\
&amp; = \text{plim}(\bar y) - \text{plim}(\hat\beta_1^{IV}) \text{plim}(\bar x) \\
&amp; = E(y) - \beta_1E(x) \\
&amp; = \beta_0
\end{split}
</span></p>
<p>Thus, the instrumental variables estimator for <span class="math inline">\beta_0</span> is also asymptotically consistent.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
<section id="variance-of-the-estimator-and-weak-instruments" class="level1">
<h1>2.5.6: Variance of the Estimator and Weak Instruments</h1>
<p>For this section, we will assume homoscedasticity (see <a href="https://statsnotes.github.io/metrics/4.html#gauss-markov-and-homoscedasticity">2.4.1</a>):</p>
<p><span class="math display">
Var(u|x) = \sigma^2
</span></p>
<p>But since <span class="math inline">x</span> is now a function of instrument <span class="math inline">z</span>, we can write the variance as:</p>
<p><span class="math display">
Var(u) = E(u^2 | z) = \sigma^2_u
</span></p>
<ul>
<li>See <a href="https://statsnotes.github.io/metrics/4.html#variance-of-ols-estimates-in-simple-linear-regression">2.4.2</a> for proof of why <span class="math inline">Var(u) = E(u^2)</span>.</li>
</ul>
<p>Now, we can find the variance. I will not derive it, since it is a little complicated and beyond what we need.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Variance of the Instrumental Variables Estimator
</div>
</div>
<div class="callout-body-container callout-body">
<p>The variance of the instrumental variable estimator <span class="math inline">\hat\beta_1^{IV}</span> is given by the formula:</p>
<p><span class="math display">
Var(\hat\beta_1^{IV}) = \frac{\sigma^2_u}{n \sigma^2_x \rho^2_{xz}}
</span></p>
<ul>
<li>Where <span class="math inline">\sigma^2_u</span> is the variance of the error term <span class="math inline">u</span>.</li>
<li>Where <span class="math inline">\sigma^2_x</span> is the variance in <span class="math inline">x</span>.</li>
<li>Where <span class="math inline">\rho_{xz}^2</span> is the square of <span class="math inline">Corr(x,z)</span>.</li>
</ul>
</div>
</div>
<p>With the variance, we can square root it to get the standard deviation of the sampling distribution. Then, we can input our sample estimates of all the parameters, to get the standard error of the Instrumental Variables estimator.</p>
<p>With the standard error, we can conduct hypotheses tests and confidence intervals as previously discussed in linear regression.</p>
<p><br></p>
<section id="weak-instruments" class="level3">
<h3 class="anchored" data-anchor-id="weak-instruments">Weak Instruments</h3>
<p>Notice how the instrumental variables estimator has <span class="math inline">\rho^2_{xz}</span>, the square of the correlation coefficient between <span class="math inline">x</span> and <span class="math inline">z</span>, in the denominator.</p>
<p>This value is always between 0 and 1. This means that if <span class="math inline">\rho^2_{xz}</span> is very small, our standard error of <span class="math inline">\hat\beta_1^{IV}</span> will be very very large.</p>
<p>But when is <span class="math inline">\rho^2_{xz}</span> very small? It is when the correlation between <span class="math inline">x</span> and <span class="math inline">z</span> is very weak. Thus, when we have <strong>weak instruments</strong> (that have a low correlation with <span class="math inline">x</span>), we will have very imprecise estimates, that are hard to draw conclusions are.</p>
<ul>
<li>IV also becomes severely biased in small samples with weak instruments.</li>
</ul>
<p>This is something to note as we delve into instrumental variables designs for research in Part III of the course.</p>
<p><br></p>
</section>
<section id="iv-variance-compared-to-ols-variance" class="level3">
<h3 class="anchored" data-anchor-id="iv-variance-compared-to-ols-variance">IV Variance compared to OLS Variance</h3>
<p>Let us recall the OLS formula for variance (homoscedastic):</p>
<p><span class="math display">
Var(\hat\beta_1^{OLS}) = \frac{\sigma^2}{SST_x}
</span></p>
<p>We know that total sum of squares of x, <span class="math inline">SST_x</span>, is equal to <span class="math inline">n \sigma^2_x</span>. Thus, we can rewrite the variance of OLS as follows:</p>
<p><span class="math display">
Var(\hat\beta_1^{OLS}) = \frac{\sigma^2}{n \sigma^2_x}
</span></p>
<p>What we notice is that the variance of OLS is very similar to the variance of the instrumental variables estimator, except that the instrumental variables estimator has an extra <span class="math inline">\rho_{xz}^2</span> in the denominator.</p>
<p>This means that the standard error of the instrumental variables estimator is roughly about <span class="math inline">1/\rho_{xz}</span> larger than the OLS estimator.</p>
<ul>
<li>Larger because <span class="math inline">\rho_{xz}</span> is the correlation coefficient, which is always between 0 and 1.</li>
</ul>
<p>Thus, when we meet the conditions for asymptotic normality for OLS (exogeneity assumption), we will always want to use OLS, since a smaller standard error means more precise hypothesis testing.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>
</section>
<section id="two-stage-least-squares-estimator" class="level1">
<h1>2.5.7: Two-Stage Least Squares Estimator</h1>
<p>We can obtain the instrumental variables estimates of <span class="math inline">\beta_1</span> and <span class="math inline">\beta_2</span> using the 2-stage least squares estimator.</p>
<p>Recall how in <a href="https://statsnotes.github.io/metrics/5.html#endogeneity-and-instrumental-variables.">2.5.3</a>, we discussed how the intuitive idea behind instrumental variables is using only parts of <span class="math inline">x</span> explained by <span class="math inline">z</span> to predict <span class="math inline">y</span>. Since <span class="math inline">z</span> is exogenous, the part of <span class="math inline">x</span> explained by <span class="math inline">z</span> should also be exogenous.</p>
<p>We can use this intuitive idea to create the 2-stage least squares estimator:</p>
<ol type="1">
<li>First, we find the part of <span class="math inline">x</span> that is explained by <span class="math inline">z</span>, which we label <span class="math inline">\hat x</span> (First-stage).</li>
<li>Then, we find the relationship between <span class="math inline">\hat x</span> and <span class="math inline">y</span> (Second-stage).</li>
</ol>
<p><br></p>
<p>The first stage involves finding the part of <span class="math inline">x</span> explained by <span class="math inline">z</span>. We can do this with a simple linear regression, with outcome variable <span class="math inline">x</span>, and explanatory variable <span class="math inline">z</span>:</p>
<p><span class="math display">
x_i = \delta_0 +\delta_1z_i + v_i
</span></p>
<ul>
<li>Where <span class="math inline">\delta_0, \delta_1</span> are coefficients, and <span class="math inline">v_i</span> is the error term.</li>
</ul>
<p>We then estimate the first stage, to create a fitted values with outcome <span class="math inline">\hat x</span>.</p>
<p><span class="math display">
\hat x_i = \hat\delta_0 + \hat\delta_1z_i
</span></p>
<p>The predicted <span class="math inline">\hat x_i</span> are the parts of <span class="math inline">x</span> that are explained by <span class="math inline">z</span> (since the unexplained parts will be a part of the error term).</p>
<p><br></p>
<p>In the second stage, we find the relationship between <span class="math inline">\hat x</span> and <span class="math inline">y</span>. We can do this with a simple linear regression, with outcome variable <span class="math inline">y</span>, and explanatory variable <span class="math inline">\hat x</span>:</p>
<p><span class="math display">
y_i = \beta_0 + \beta_1 \hat x_i + u_i
</span></p>
<p>We then estimate the second stage, to create the fitted values of <span class="math inline">y</span>:</p>
<p><span class="math display">
\hat y_i = \hat\beta_0 + \hat\beta_1 \hat x_i
</span></p>
<p>Where <span class="math inline">\hat\beta_1</span> is the 2 stage least squares estimate of the true coefficient <span class="math inline">\beta_1</span> (relationship between <span class="math inline">x</span> and <span class="math inline">y</span>. We will often label this estimate <span class="math inline">\hat\beta_1^{2SLS}</span>.</p>
<p><br></p>
<p>There are two main advantages of the two-stage-least-squares estimator.</p>
<p>First of all, the two stage least squares is relatively straight forward to calculate, especially with statistical software.</p>
<p>But probably the more important benefit is that the 2-stage-least-squares can help us check the assumption of relevance of the instrumental variable <span class="math inline">z</span>.</p>
<p>Remember, the assumption of relevance means that <span class="math inline">Cov(z,x)≠0</span>. We can test this with the first stage of the regression:</p>
<p><span class="math display">
x_i = \delta_0 + \delta_1z_i + v_i
</span></p>
<p>If our estimate <span class="math inline">\hat\delta_1</span> is statistically significant, then we know that there is a statistically significant relationship between <span class="math inline">x</span> and <span class="math inline">z</span>. Given that, we know that this assumption has been met.</p>
<p><br></p>
<p>There is another equation in the 2-stage-least-squares method, that isn’t the “main goal” of the estimator, but can be useful for some applications: the reduced form equation.</p>
<p>The reduced form equation is the regression with outcome <span class="math inline">y</span>, and explanatory variable <span class="math inline">z</span>:</p>
<p><span class="math display">
y_i = \gamma_0 + \gamma_1z_i + e_i
</span></p>
<ul>
<li>Where <span class="math inline">\gamma_0, \gamma_1</span> are coefficients, and <span class="math inline">e_i</span> is the error term.</li>
</ul>
<p>The reduced form equation is not too relevant for us right now, but in causal inference research designs, it does have a meaningful meaning (as we will discuss in Part III of the course).</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://statsnotes.github.io">Homepage</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>